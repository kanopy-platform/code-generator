package generators

import (
	"fmt"
	"go/token"
	"io"
	"path/filepath"
	"strings"

	"k8s.io/gengo/args"
	"k8s.io/gengo/examples/set-gen/sets"
	"k8s.io/gengo/generator"
	"k8s.io/gengo/namer"
	"k8s.io/gengo/types"

	"k8s.io/klog/v2"
)

// CustomArgs is used tby the go2idl framework to pass args specific to this
// generator.
type CustomArgs struct {
	BoundingDirs []string // Only deal with types rooted under these dirs.
}

const (
	// This is the comment tag that carries parameters for builder generation.
	tagEnabledName = "kanopy:builder"

	// Known values for the comment tag.
	tagValuePackage = "package"
)

// enabledTagValue holds parameters from a tagName tag.
type enabledTagValue struct {
	value string
}

// NameSystems returns the name system used by the generators in this package.
func NameSystems() namer.NameSystems {
	return namer.NameSystems{
		"public": defaultNamer(),
		"raw":    namer.NewRawNamer("", nil),
	}
}

// DefaultNameSystem returns the default name system for ordering the types to be
// processed by the generators in this package.
func DefaultNameSystem() string {
	return "public"
}

func Packages(context *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
	boilerplate, err := arguments.LoadGoBoilerplate()
	if err != nil {
		klog.Fatalf("Failed loading boilerplate: %v", err)
	}

	inputs := sets.NewString(context.Inputs...)
	packages := generator.Packages{}
	header := append([]byte(fmt.Sprintf("// +build !%s\n\n", arguments.GeneratedBuildTag)), boilerplate...)

	boundingDirs := []string{}
	if customArgs, ok := arguments.CustomArgs.(*CustomArgs); ok {
		if customArgs.BoundingDirs == nil {
			customArgs.BoundingDirs = context.Inputs
		}
		for i := range customArgs.BoundingDirs {
			// Strip any trailing slashes - they are not exactly "correct" but
			// this is friendlier.
			boundingDirs = append(boundingDirs, strings.TrimRight(customArgs.BoundingDirs[i], "/"))
		}
	}

	for i := range inputs {
		klog.V(5).Infof("Considering pkg %q", i)
		pkg := context.Universe[i]
		if pkg == nil {
			// If the input had no Go files, for example.
			continue
		}

		ptag := extractTag(tagEnabledName, pkg.Comments)
		ptagValue := ""

		if ptag != nil {
			ptagValue = ptag.value
			if ptagValue != tagValuePackage {
				klog.Fatalf("Package %v: unsupported %s value: %q", i, tagEnabledName, ptagValue)
			}
			klog.V(5).Infof("  tag.value: %q", ptagValue)
		} else {
			klog.V(5).Infof("  no tag")
		}

		// If the pkg-scoped tag says to generate, we can skip scanning types.
		pkgNeedsGeneration := (ptagValue == tagValuePackage)
		if !pkgNeedsGeneration {
			// If the pkg-scoped tag did not exist, scan all types for one that
			// explicitly wants generation.
			for _, t := range pkg.Types {
				klog.V(5).Infof("  considering type %q", t.Name.String())
				ttag := extractTagsType(tagEnabledName, t)
				if ttag != nil && ttag.value == "true" {
					klog.V(5).Infof("    tag=true")
					pkgNeedsGeneration = true
					break
				}
			}
		}

		if pkgNeedsGeneration {
			klog.V(3).Infof("Package %q needs generation", i)
			path := pkg.Path

			packages = append(packages,
				&generator.DefaultPackage{
					PackageName: strings.Split(filepath.Base(pkg.Path), ".")[0],
					PackagePath: path,
					HeaderText:  header,
					GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
						return []generator.Generator{
							NewGenBuilder(arguments.OutputFileBaseName, pkg.Path, boundingDirs, (ptagValue == tagValuePackage)),
						}
					},
					FilterFunc: func(c *generator.Context, t *types.Type) bool {
						return t.Name.Package == pkg.Path
					},
				})
		}
	}
	return packages
}

// genBuilder produces a file with autogenerated deep-copy functions.
type genBuilder struct {
	generator.DefaultGen
	targetPackage string
	boundingDirs  []string
	allTypes      bool
	utilsIncluded bool
	imports       namer.ImportTracker
	typesForInit  []*types.Type
}

func NewGenBuilder(sanitizedName, targetPackage string, boundingDirs []string, allTypes bool) generator.Generator {
	return &genBuilder{
		DefaultGen: generator.DefaultGen{
			OptionalName: sanitizedName,
		},
		targetPackage: targetPackage,
		boundingDirs:  boundingDirs,
		allTypes:      allTypes,
		imports:       setupCustomImportTracker(),
		typesForInit:  make([]*types.Type, 0),
	}
}

func (g *genBuilder) Namers(c *generator.Context) namer.NameSystems {
	// Have the raw namer for this file track what it imports.
	return namer.NameSystems{
		"raw": namer.NewRawNamer(g.targetPackage, g.imports),
	}
}

func (g *genBuilder) Filter(c *generator.Context, t *types.Type) bool {
	// Filter out types not being processed or not copyable within the package.
	enabled := g.allTypes
	if !enabled {
		ttag := extractTagsType(tagEnabledName, t)
		if ttag != nil && ttag.value == "true" {
			enabled = true
		}
	}
	if !enabled {
		return false
	}

	klog.V(4).Infof("Type %v contains a builder", t)
	g.typesForInit = append(g.typesForInit, t)
	return true
}

func (g *genBuilder) isOtherPackage(pkg string) bool {
	if pkg == g.targetPackage {
		return false
	}
	if strings.HasSuffix(pkg, "\""+g.targetPackage+"\"") {
		return false
	}
	return true
}

func (g *genBuilder) Imports(c *generator.Context) (imports []string) {
	importLines := []string{}
	for _, singleImport := range g.imports.ImportLines() {
		if g.isOtherPackage(singleImport) {
			importLines = append(importLines, singleImport)
		}
	}

	return importLines
}

func (g *genBuilder) Init(c *generator.Context, w io.Writer) error {
	return nil
}

func (g *genBuilder) needsGeneration(t *types.Type) bool {
	tag := extractTagsType(tagEnabledName, t)
	tv := ""

	if tag != nil {
		tv = tag.value
		if tv != "true" && tv != "false" {
			klog.Fatalf("Type %v: unsupported %s value: %q", t, tagEnabledName, tag.value)
		}
	}

	if g.allTypes && tv == "false" {
		// The whole package is being generated, but this type has opted out.
		klog.V(5).Infof("Not generating for type %v because type opted out", t)
		return false
	}
	if !g.allTypes && tv != "true" {
		// The whole package is NOT being generated, and this type has NOT opted in.
		klog.V(5).Infof("Not generating for type %v because type did not opt in", t)
		return false
	}
	return true
}

func (g *genBuilder) generateUtils(c *generator.Context, w io.Writer) error {
	sw := generator.NewSnippetWriter(w, c, "$", "$")

	sw.Do("// mergeMapStringString creates a new map and loads it from map args\n", nil)
	sw.Do("// this function takes a least 2 args and later map args take precedence.\n", nil)
	sw.Do("func mergeMapStringString(m1 map[string]string, mapArgs ...map[string]string) map[string]string {\n", nil)
	sw.Do("// populate initial map\n", nil)
	sw.Do("outMap := map[string]string{}\n", nil)
	sw.Do("for k, v := range m1 {\n", nil)
	sw.Do("outMap[k] = v\n", nil)
	sw.Do("	}\n", nil)
	sw.Do("	// iterate all args\n", nil)
	sw.Do("	for _, m := range mapArgs {\n", nil)
	sw.Do("		for k, v := range m {\n", nil)
	sw.Do("			outMap[k] = v\n", nil)
	sw.Do("		}\n", nil)
	sw.Do("	}\n", nil)

	sw.Do("	return outMap\n", nil)
	sw.Do("}\n", nil)

	return sw.Error()
}

func (g *genBuilder) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	if !g.needsGeneration(t) {
		return nil
	}
	klog.V(5).Infof("Generating TypeMeta function for type %v", t)
	sw := generator.NewSnippetWriter(w, c, "$", "$")
	args := argsFromType(t)

	// generate With* Methods of embeded type
	emType := embededTypeMetaForType(t)

	if !g.utilsIncluded {
		err := g.generateUtils(c, w)
		if err != nil {
			return err
		}
		g.utilsIncluded = true
	}

	fmt.Println("generating setters...")

	if emType != nil {
		g.imports.AddType(emType)
		sw.Do("// MarshalJSON is an autogenerated marshaling function, setting the TypeMeta.\n", args)
		fmt.Println("Package ", emType.Name.Package)
		args["alias"] = g.imports.LocalNameOf(emType.Name.Package)
		sw.Do("func (o $.type|raw$) MarshalJSON() ([]byte, error) {\n", args)
		sw.Do("o.$.type|raw$.TypeMeta = metav1.TypeMeta{Kind: \"$.type|raw$\", APIVersion: $.alias$.SchemeGroupVersion.String()}\n", args)
		sw.Do("return json.Marshal(o.$.type|raw$)\n", args)
		sw.Do("}\n\n", nil)

		sw.Do("// DeepCopyInto is an autogenerated function\n", nil)
		sw.Do("func (in *$.type|raw$) DeepCopyInto(out *$.type|raw$) {\n", args)
		sw.Do("in.$.type|raw$.DeepCopyInto(&out.$.type|raw$)\n", args)
		sw.Do("}\n\n", nil)

		sw.Do("// DeepCopy is an autogenerated function\n", nil)
		sw.Do("func (in *$.type|raw$) DeepCopy() *$.type|raw$ {\n", args)
		sw.Do("if in == nil {\n", nil)
		sw.Do("return nil\n", nil)
		sw.Do("}\n", nil)
		sw.Do("out := new($.type|raw$)\n", args)
		sw.Do("in.DeepCopyInto(out)\n", nil)
		sw.Do("return out\n", nil)
		sw.Do("}\n\n", nil)

		if emType != nil {
			for _, m := range emType.Members {
				if m.Name == "TypeMeta" || m.Name == "Status" {
					continue
				}
				g.imports.AddType(m.Type)
				fmt.Println("Member: ", m.Name, m.Embedded)
				isInit, _ := g.isTypeEnabledForGeneration(m.Type)
				if !isInit && !m.Embedded {
					fmt.Println("[SKIPING] ", m.Type)
				}
				if m.Embedded {
					g.generateStruct(sw, t, emType, m.Type)
				} else if !m.Embedded && isInit {

					// generate single setter
					args["member"] = m.Type.Name.Name
					verb := "With"
					if m.Type.Kind == types.Slice {
						verb = "Append"
					}
					args["name"] = fmt.Sprintf("%s%s", verb, m.Name)

					assignment := "o.$.member$"
					if m.Name != m.Type.Name.Name {
						assignment = fmt.Sprintf("o.%s", m.Name)
					}

					sw.Do("//$.name$ is an autogenerated setter function.\n", args)
					switch m.Type.Kind {
					case types.Slice:

						sw.Do("func (o *$.type|raw$) $.name$(in ...$.member$) *$.type|raw$ {\n", args)
						// needs translation from struct to pull out the embedd object.
						sw.Do("for _, i := range in {\n", nil)
						sw.Do(fmt.Sprintf("%s = append(%s, i.$.member|raw$)\n", assignment, assignment), args)
						sw.Do("}\n", nil)
					case types.Struct:
						sw.Do("func (o *$.type|raw$) $.name$(in $.member$) *$.type|raw$ {\n", args)
						sw.Do(fmt.Sprintf("%s = in.$.member$\n", assignment), args)
					default:
						sw.Do("func (o *$.type|raw$) $.name$(in $.member$) *$.type|raw$ {\n", args)
						sw.Do(fmt.Sprintf("%s = in\n", assignment), args)
					}

					sw.Do("return o\n", nil)
					sw.Do("}\n\n", nil)
				}

			}
		}
	} else {
		g.generateStruct(sw, t, t, t)
	}

	return sw.Error()
}

func (g *genBuilder) generateStruct(sw *generator.SnippetWriter, root *types.Type, parent *types.Type, child *types.Type) {
	if child != nil {
		for _, m := range child.Members {
			if m.Name == "ManagedFields" || m.Name == "GenerateName" {
				continue
			}
			if !isReadonly(m.CommentLines) {
				fmt.Println("\tName: ", m.Name, m.Type.Kind, m.Embedded, m.Type)

				if m.Embedded {
					g.generateStruct(sw, root, child, m.Type)
					continue
				}

				fmt.Println("\tChild Name: ", child.Name)
				verb := "With"

				args := argsFromType(root)

				args["m"] = m.Type
				args["member"] = m.Name

				isInit, embed := g.isTypeEnabledForGeneration(m.Type)

				if !isInit {
					fmt.Println("[SKIPING] ", m.Type)
					continue
				}

				if embed != nil {
					args["m"] = embed
				}

				assignment := "o.$.member$"
				if parent != child {
					assignment = "o.$.type|raw$.$.member$"
				}

				if m.Type.Kind == types.Slice {
					verb = "Append"
				}

				args["name"] = fmt.Sprintf("%s%s", verb, m.Name)

				sw.Do("//$.name$ is an autogenerated setter function.\n", args)

				switch m.Type.Kind {
				case types.Map:
					sw.Do("func (o *$.type|raw$) $.name$(in $.m|raw$) *$.type|raw$ {\n", args)
					sw.Do(fmt.Sprintf("%s = mergeMapStringString(%s, in)\n", assignment, assignment), args)
				case types.Slice:
					if embed != nil {
						sw.Do("func (o *$.type|raw$) $.name$(in ...$.m|raw$) *$.type|raw$ {\n", args)
						// needs translation from struct to pull out the embedd object.
						sw.Do("for _, i := range in {\n", nil)
						sw.Do(fmt.Sprintf("%s = append(%s, i.$.m|raw$)\n", assignment, assignment), args)
						sw.Do("}\n", nil)
					} else {
						sw.Do("func (o *$.type|raw$) $.name$(in $.m|raw$) *$.type|raw$ {\n", args)
						sw.Do(fmt.Sprintf("%s = append(%s, in...)\n", assignment, assignment), args)
					}
				default:
					sw.Do("func (o *$.type|raw$) $.name$(in $.m|raw$) *$.type|raw$ {\n", args)
					sw.Do(fmt.Sprintf("%s = in\n", assignment), args)
				}

				sw.Do("return o\n", nil)
				sw.Do("}\n\n", nil)
			}
		}

	}
}

func (g *genBuilder) isTypeEnabledForGeneration(t *types.Type) (bool, *types.Type) {
	pathName := fmt.Sprintf("%s", t.Name)

	if t.Kind == types.Slice {
		pathName = strings.Replace(pathName, "[]", "", 1)
	}

	if !strings.Contains(pathName, "/") {
		return true, nil
	}

	for _, a := range g.typesForInit {
		klog.V(2).Infof("Checking type %s is included for generation: %s", a.Name, t.Name)

		for _, m := range a.Members {
			if m.Embedded {
				s := fmt.Sprintf("%s", m.Type.Name)

				if s == pathName {
					return true, a
				}
			}
		}

		if a.Name == t.Name {
			return true, a
		}
	}
	return false, nil
}

// Utils

func argsFromType(ts ...*types.Type) generator.Args {
	a := generator.Args{
		"type": ts[0],
	}
	for i, t := range ts {
		a[fmt.Sprintf("type%d", i+1)] = t
	}
	return a
}

func embededTypeMetaForType(t *types.Type) *types.Type {
	var emType *types.Type

	for _, m := range t.Members {
		if m.Embedded {
			et := m.Type
			for _, mm := range et.Members {
				if mm.Name == "TypeMeta" {
					emType = m.Type
					break
				}
			}
		}
	}
	return emType
}

func isReadonly(ss []string) bool {
	for _, s := range ss {
		if !strings.Contains(s, "Read-only") {
			continue
		}
		return true
	}
	return false
}

func setupCustomImportTracker(typesToAdd ...*types.Type) namer.ImportTracker {
	tracker := namer.NewDefaultImportTracker(types.Name{})
	tracker.IsInvalidType = func(*types.Type) bool { return false }
	tracker.LocalName = func(name types.Name) string { return golangTrackerLocalName(&tracker, name) }
	tracker.PrintImport = func(path, name string) string { return name + " \"" + path + "\"" }

	tracker.AddTypes(typesToAdd...)
	return &tracker
}

func golangTrackerLocalName(tracker namer.ImportTracker, t types.Name) string {
	path := t.Package

	// Using backslashes in package names causes gengo to produce Go code which
	// will not compile with the gc compiler. See the comment on GoSeperator.
	if strings.ContainsRune(path, '\\') {
		klog.Warningf("Warning: backslash used in import path '%v', this is unsupported.\n", path)
	}

	dirs := strings.Split(path, namer.GoSeperator)
	for n := len(dirs) - 2; n >= 0; n-- {
		// follow kube convention of not having anything between directory names
		name := strings.Join(dirs[n:], "")
		name = strings.Replace(name, "_", "", -1)
		// These characters commonly appear in import paths for go
		// packages, but aren't legal go names. So we'll sanitize.
		name = strings.Replace(name, ".", "", -1)
		name = strings.Replace(name, "-", "", -1)
		if _, found := tracker.PathOf(name); found {
			// This name collides with some other package
			continue
		}

		// If the import name is a Go keyword, prefix with an underscore.
		if token.Lookup(name).IsKeyword() {
			name = "_" + name
		}
		return name
	}
	panic("can't find import for " + path)
}

func extractTagsType(tagName string, t *types.Type) *enabledTagValue {
	comments := append(append([]string{}, t.SecondClosestCommentLines...), t.CommentLines...)
	return extractTag(tagName, comments)
}

func extractTag(tagName string, comments []string) *enabledTagValue {
	tagVals := types.ExtractCommentTags("+", comments)[tagName]
	if tagVals == nil {
		// No match for the tag.
		return nil
	}
	// If there are multiple values, abort.
	if len(tagVals) > 1 {
		klog.Fatalf("Found %d %s tags: %q", len(tagVals), tagName, tagVals)
	}

	// If we got here we are returning something.
	tag := &enabledTagValue{}

	// Get the primary value.
	parts := strings.Split(tagVals[0], ",")
	if len(parts) >= 1 {
		tag.value = parts[0]
	}
	return tag
}

// TODO: This is created only to reduce number of changes in a single PR.
// Remove it and use PublicNamer instead.
func defaultNamer() *namer.NameStrategy {
	return &namer.NameStrategy{
		Join: func(pre string, in []string, post string) string {
			return strings.Join(in, "_")
		},
		PrependPackageNames: 1,
	}
}
