package snippets

import (
	"bytes"
	"testing"

	"github.com/kanopy-platform/code-generator/pkg/generators/snippets/testdata/a"
	"github.com/kanopy-platform/code-generator/pkg/generators/snippets/testdata/b"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"k8s.io/gengo/generator"
	"k8s.io/gengo/types"
)

func TestGenerateSetterPrimitive(t *testing.T) {
	t.Parallel()

	ctx, err := newTestGeneratorContext()
	require.NoError(t, err)

	someStruct := newTestType(t, "SomeStruct")

	tests := []struct {
		ctx    *generator.Context
		root   *types.Type
		member types.Member
		want   string
	}{
		{
			ctx:    ctx,
			root:   someStruct,
			member: someStruct.Members[0].Type.Members[a.MemberIndex_SomeStruct_ObjectMeta].Type.Members[b.MemberIndex_ObjectMeta_Name], // SomeStruct.SomeStruct.ObjectMeta.Name
			want: `// WithName is an autogenerated function
func (o *SomeStruct) WithName(in string) *SomeStruct {
	o.Name = in
	return o
}

`,
		},
	}

	for _, test := range tests {
		var b bytes.Buffer
		sw := generator.NewSnippetWriter(&b, test.ctx, "$", "$")
		sw.Do(GenerateSetterPrimitive(test.root, test.member))
		assert.NoError(t, sw.Error())
		assert.Equal(t, test.want, b.String())
	}
}

func TestGenerateSetterMap(t *testing.T) {
	t.Parallel()

	ctx, err := newTestGeneratorContext()
	require.NoError(t, err)

	someStruct := newTestType(t, "SomeStruct")

	tests := []struct {
		ctx    *generator.Context
		root   *types.Type
		member types.Member
		want   string
	}{
		{
			ctx:    ctx,
			root:   someStruct,
			member: someStruct.Members[0].Type.Members[a.MemberIndex_SomeStruct_ObjectMeta].Type.Members[b.MemberIndex_ObjectMeta_Labels], // SomeStruct.SomeStruct.ObjectMeta.Labels
			want: `// WithLabels is an autogenerated function
func (o *SomeStruct) WithLabels(in map[string]string) *SomeStruct {
	o.Labels = mergeMapStringString(o.Labels, in)
	return o
}

`,
		},
	}

	for _, test := range tests {
		var b bytes.Buffer
		sw := generator.NewSnippetWriter(&b, test.ctx, "$", "$")
		sw.Do(GenerateSetterMap(test.root, test.member))
		assert.NoError(t, sw.Error())
		assert.Equal(t, test.want, b.String())
	}
}

func TestGenerateSetterSlice(t *testing.T) {
	t.Parallel()

	ctx, err := newTestGeneratorContext()
	require.NoError(t, err)

	someStruct := newTestType(t, "SomeStruct")
	cStruct := newTestType(t, "CStruct")

	tests := []struct {
		ctx     *generator.Context
		root    *types.Type
		member  types.Member
		wrapper *types.Type
		want    string
	}{
		{
			// embedded type
			ctx:     ctx,
			root:    someStruct,
			member:  someStruct.Members[0].Type.Members[a.MemberIndex_SomeStruct_CStructs], // SomeStruct.SomeStruct.CStructs
			wrapper: cStruct,                                                               // c.CStruct
			want: `// AppendCStructs is an autogenerated function
func (o *SomeStruct) AppendCStructs(in ...CStruct) *SomeStruct {
	for _, elem := range in {
		o.CStructs = append(o.CStructs, elem.CStruct)
	}
	return o
}

`,
		},
		{
			// builtin or non-embedded type
			ctx:    ctx,
			root:   someStruct,
			member: someStruct.Members[0].Type.Members[a.MemberIndex_SomeStruct_Strings], // SomeStruct.SomeStruct.Strings
			want: `// AppendStrings is an autogenerated function
func (o *SomeStruct) AppendStrings(in ...string) *SomeStruct {
	o.Strings = append(o.Strings, in...)
	return o
}

`,
		},
	}

	for _, test := range tests {
		var b bytes.Buffer
		sw := generator.NewSnippetWriter(&b, test.ctx, "$", "$")
		sw.Do(GenerateSetterSlice(test.root, test.member, test.wrapper))
		assert.NoError(t, sw.Error())
		assert.Equal(t, test.want, b.String())
	}
}

func TestGenerateSetterStruct(t *testing.T) {
	t.Parallel()

	ctx, err := newTestGeneratorContext()
	require.NoError(t, err)

	someStruct := newTestType(t, "SomeStruct")
	cStruct := newTestType(t, "CStruct")

	tests := []struct {
		ctx     *generator.Context
		root    *types.Type
		member  types.Member
		wrapper *types.Type
		want    string
	}{
		{
			// embedded type
			ctx:     ctx,
			root:    someStruct,
			member:  someStruct.Members[0].Type.Members[a.MemberIndex_SomeStruct_CStruct], // SomeStruct.SomeStruct.CStruct
			wrapper: cStruct,                                                              // c.CStruct
			want: `// WithCStruct is an autogenerated function
func (o *SomeStruct) WithCStruct(in CStruct) *SomeStruct {
	o.CStruct = in.CStruct
	return o
}

`,
		},
		{
			// builtin or non-embedded type
			ctx:    ctx,
			root:   someStruct,
			member: someStruct.Members[0].Type.Members[a.MemberIndex_SomeStruct_AStruct], // SomeStruct.SomeStruct.AStruct
			want: `// WithAStruct is an autogenerated function
func (o *SomeStruct) WithAStruct(in a.AStruct) *SomeStruct {
	o.AStruct = in
	return o
}

`,
		},
	}

	for _, test := range tests {
		var b bytes.Buffer
		sw := generator.NewSnippetWriter(&b, test.ctx, "$", "$")
		sw.Do(GenerateSetterStruct(test.root, test.member, test.wrapper))
		assert.NoError(t, sw.Error())
		assert.Equal(t, test.want, b.String())
	}
}

func TestGenerateSetterPointerBuiltin(t *testing.T) {
	t.Parallel()

	ctx, err := newTestGeneratorContext()
	require.NoError(t, err)

	someStruct := newTestType(t, "SomeStruct")

	tests := []struct {
		ctx    *generator.Context
		root   *types.Type
		member types.Member
		want   string
	}{
		{
			// embedded type
			ctx:    ctx,
			root:   someStruct,
			member: someStruct.Members[0].Type.Members[a.MemberIndex_SomeStruct_IntPtr], // SomeStruct.SomeStruct.Intptr
			want: `// WithIntPtr is an autogenerated function
func (o *SomeStruct) WithIntPtr(in int) *SomeStruct {
	o.IntPtr = &in
	return o
}

`,
		},
	}

	for _, test := range tests {
		var b bytes.Buffer
		sw := generator.NewSnippetWriter(&b, test.ctx, "$", "$")
		sw.Do(GenerateSetterPointerBuiltin(test.root, test.member))
		assert.NoError(t, sw.Error())
		assert.Equal(t, test.want, b.String())
	}
}

func TestFuncName(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		kind types.Kind
		want string
	}{
		{
			name: "Name",
			kind: types.Builtin,
			want: "WithName",
		},
		{
			name: "Struct",
			kind: types.Struct,
			want: "WithStruct",
		},
		{
			name: "Slice",
			kind: types.Slice,
			want: "AppendSlice",
		},
	}

	for _, test := range tests {
		m := types.Member{
			Name: test.name,
			Type: &types.Type{
				Kind: test.kind,
			},
		}

		assert.Equal(t, test.want, funcName(m))
	}
}
