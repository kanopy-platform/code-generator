package snippets

import (
	"bytes"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"k8s.io/gengo/generator"
	"k8s.io/gengo/types"
)

func TestGenerateSetterForPrimitiveType(t *testing.T) {
	t.Parallel()

	ctx, err := newTestGeneratorContext()
	require.NoError(t, err)

	someStruct := newTestType(t, "SomeStruct")

	tests := []struct {
		root   *types.Type
		parent *types.Type
		member types.Member
		want   string
	}{
		{
			root:   someStruct,
			parent: someStruct,
			member: getMemberFromType(t, someStruct, "SomeStruct", "ObjectMeta", "Name"), // SomeStruct.SomeStruct.ObjectMeta.Name
			want: `// WithName is an autogenerated function
func (o *SomeStruct) WithName(in string) *SomeStruct {
	o.Name = in
	return o
}

`,
		},
		{
			root:   someStruct,
			parent: someStruct.Members[0].Type,
			member: getMemberFromType(t, someStruct, "SomeStruct", "ObjectMeta", "Name"), // SomeStruct.SomeStruct.ObjectMeta.Name
			want: `// WithName is an autogenerated function
func (o *SomeStruct) WithName(in string) *SomeStruct {
	o.SomeStruct.Name = in
	return o
}

`,
		},
	}

	for _, test := range tests {
		var b bytes.Buffer
		sw := generator.NewSnippetWriter(&b, ctx, "$", "$")
		sw.Do(GenerateSetterForPrimitiveType(test.root, test.parent, test.member))
		assert.NoError(t, sw.Error())
		assert.Equal(t, test.want, b.String())
	}
}

func TestGenerateSetterForMap(t *testing.T) {
	t.Parallel()

	ctx, err := newTestGeneratorContext()
	require.NoError(t, err)

	someStruct := newTestType(t, "SomeStruct")

	tests := []struct {
		root   *types.Type
		parent *types.Type
		member types.Member
		want   string
	}{
		{
			root:   someStruct,
			parent: someStruct,
			member: getMemberFromType(t, someStruct, "SomeStruct", "ObjectMeta", "Labels"), // SomeStruct.SomeStruct.ObjectMeta.Labels
			want: `// WithLabels is an autogenerated function
func (o *SomeStruct) WithLabels(in map[string]string) *SomeStruct {
	o.Labels = mergeMapStringString(o.Labels, in)
	return o
}

`,
		},
		{
			root:   someStruct,
			parent: someStruct.Members[0].Type,
			member: getMemberFromType(t, someStruct, "SomeStruct", "ObjectMeta", "Labels"), // SomeStruct.SomeStruct.ObjectMeta.Labels
			want: `// WithLabels is an autogenerated function
func (o *SomeStruct) WithLabels(in map[string]string) *SomeStruct {
	o.SomeStruct.Labels = mergeMapStringString(o.SomeStruct.Labels, in)
	return o
}

`,
		},
	}

	for _, test := range tests {
		var b bytes.Buffer
		sw := generator.NewSnippetWriter(&b, ctx, "$", "$")
		sw.Do(GenerateSetterForMap(test.root, test.parent, test.member))
		assert.NoError(t, sw.Error())
		assert.Equal(t, test.want, b.String())
	}
}

func TestGenerateSetterForMemberSlice(t *testing.T) {
	t.Parallel()

	ctx, err := newTestGeneratorContext()
	require.NoError(t, err)

	someStruct := newTestType(t, "SomeStruct")

	tests := []struct {
		root   *types.Type
		parent *types.Type
		member types.Member
		want   string
	}{
		{
			root:   someStruct,
			parent: someStruct,
			member: getMemberFromType(t, someStruct, "SomeStruct", "Strings"), // SomeStruct.SomeStruct.Strings
			want: `// AppendStrings is an autogenerated function
func (o *SomeStruct) AppendStrings(in ...string) *SomeStruct {
	o.Strings = append(o.Strings, in...)
	return o
}

`,
		},
		{
			root:   someStruct,
			parent: someStruct.Members[0].Type,
			member: getMemberFromType(t, someStruct, "SomeStruct", "Strings"), // SomeStruct.SomeStruct.Strings
			want: `// AppendStrings is an autogenerated function
func (o *SomeStruct) AppendStrings(in ...string) *SomeStruct {
	o.SomeStruct.Strings = append(o.SomeStruct.Strings, in...)
	return o
}

`,
		},
	}

	for _, test := range tests {
		var b bytes.Buffer
		sw := generator.NewSnippetWriter(&b, ctx, "$", "$")
		sw.Do(GenerateSetterForMemberSlice(test.root, test.parent, test.member))
		assert.NoError(t, sw.Error())
		assert.Equal(t, test.want, b.String())
	}
}

func TestGenerateSetterForEmbeddedSlice(t *testing.T) {
	t.Parallel()

	ctx, err := newTestGeneratorContext()
	require.NoError(t, err)

	someStruct := newTestType(t, "SomeStruct")
	cStruct := newTestType(t, "CStruct")

	tests := []struct {
		root      *types.Type
		parent    *types.Type
		member    types.Member
		inputType *types.Type
		want      string
	}{
		{
			root:      someStruct,
			parent:    someStruct,
			member:    getMemberFromType(t, someStruct, "SomeStruct", "CStructs"), // SomeStruct.SomeStruct.CStructs
			inputType: cStruct,                                                    // c.CStruct
			want: `// AppendCStructs is an autogenerated function
func (o *SomeStruct) AppendCStructs(in ...CStruct) *SomeStruct {
	for _, elem := range in {
		o.CStructs = append(o.CStructs, elem.CStruct)
	}
	return o
}

`,
		},
		{
			root:      someStruct,
			parent:    someStruct.Members[0].Type,
			member:    getMemberFromType(t, someStruct, "SomeStruct", "CStructs"), // SomeStruct.SomeStruct.CStructs
			inputType: cStruct,                                                    // c.CStruct
			want: `// AppendCStructs is an autogenerated function
func (o *SomeStruct) AppendCStructs(in ...CStruct) *SomeStruct {
	for _, elem := range in {
		o.SomeStruct.CStructs = append(o.SomeStruct.CStructs, elem.CStruct)
	}
	return o
}

`,
		},
	}

	for _, test := range tests {
		var b bytes.Buffer
		sw := generator.NewSnippetWriter(&b, ctx, "$", "$")
		sw.Do(GenerateSetterForEmbeddedSlice(test.root, test.parent, test.member, test.inputType))
		assert.NoError(t, sw.Error())
		assert.Equal(t, test.want, b.String())
	}
}

func TestGenerateSetterForMemberStruct(t *testing.T) {
	t.Parallel()

	ctx, err := newTestGeneratorContext()
	require.NoError(t, err)

	someStruct := newTestType(t, "SomeStruct")

	tests := []struct {
		root   *types.Type
		parent *types.Type
		member types.Member
		want   string
	}{
		{
			root:   someStruct,
			parent: someStruct,
			member: getMemberFromType(t, someStruct, "SomeStruct", "AStruct"), // SomeStruct.SomeStruct.AStruct
			want: `// WithAStruct is an autogenerated function
func (o *SomeStruct) WithAStruct(in a.AStruct) *SomeStruct {
	o.AStruct = in
	return o
}

`,
		},
		{
			root:   someStruct,
			parent: someStruct.Members[0].Type,
			member: getMemberFromType(t, someStruct, "SomeStruct", "AStruct"), // SomeStruct.SomeStruct.AStruct
			want: `// WithAStruct is an autogenerated function
func (o *SomeStruct) WithAStruct(in a.AStruct) *SomeStruct {
	o.SomeStruct.AStruct = in
	return o
}

`,
		},
	}

	for _, test := range tests {
		var b bytes.Buffer
		sw := generator.NewSnippetWriter(&b, ctx, "$", "$")
		sw.Do(GenerateSetterForMemberStruct(test.root, test.parent, test.member))
		assert.NoError(t, sw.Error())
		assert.Equal(t, test.want, b.String())
	}
}

func TestGenerateSetterForEmbeddedStruct(t *testing.T) {
	t.Parallel()

	ctx, err := newTestGeneratorContext()
	require.NoError(t, err)

	someStruct := newTestType(t, "SomeStruct")
	cStruct := newTestType(t, "CStruct")

	tests := []struct {
		root      *types.Type
		parent    *types.Type
		member    types.Member
		inputType *types.Type
		want      string
	}{
		{
			root:      someStruct,
			parent:    someStruct,
			member:    getMemberFromType(t, someStruct, "SomeStruct", "CStruct"), // SomeStruct.SomeStruct.CStruct
			inputType: cStruct,                                                   // c.CStruct
			want: `// WithCStruct is an autogenerated function
func (o *SomeStruct) WithCStruct(in CStruct) *SomeStruct {
	o.CStruct = in.CStruct
	return o
}

`,
		},
		{
			root:      someStruct,
			parent:    someStruct.Members[0].Type,
			member:    getMemberFromType(t, someStruct, "SomeStruct", "CStruct"), // SomeStruct.SomeStruct.CStruct
			inputType: cStruct,                                                   // c.CStruct
			want: `// WithCStruct is an autogenerated function
func (o *SomeStruct) WithCStruct(in CStruct) *SomeStruct {
	o.SomeStruct.CStruct = in.CStruct
	return o
}

`,
		},
	}

	for _, test := range tests {
		var b bytes.Buffer
		sw := generator.NewSnippetWriter(&b, ctx, "$", "$")
		sw.Do(GenerateSetterForEmbeddedStruct(test.root, test.parent, test.member, test.inputType))
		assert.NoError(t, sw.Error())
		assert.Equal(t, test.want, b.String())
	}
}

func TestGenerateSetterForPointerToBuiltinType(t *testing.T) {
	t.Parallel()

	ctx, err := newTestGeneratorContext()
	require.NoError(t, err)

	someStruct := newTestType(t, "SomeStruct")

	tests := []struct {
		root   *types.Type
		parent *types.Type
		member types.Member
		want   string
	}{
		{
			root:   someStruct,
			parent: someStruct,
			member: getMemberFromType(t, someStruct, "SomeStruct", "IntPtr"), // SomeStruct.SomeStruct.IntPtr
			want: `// WithIntPtr is an autogenerated function
func (o *SomeStruct) WithIntPtr(in int) *SomeStruct {
	o.IntPtr = &in
	return o
}

`,
		},
		{
			root:   someStruct,
			parent: someStruct.Members[0].Type,
			member: getMemberFromType(t, someStruct, "SomeStruct", "IntPtr"), // SomeStruct.SomeStruct.IntPtr
			want: `// WithIntPtr is an autogenerated function
func (o *SomeStruct) WithIntPtr(in int) *SomeStruct {
	o.SomeStruct.IntPtr = &in
	return o
}

`,
		},
	}

	for _, test := range tests {
		var b bytes.Buffer
		sw := generator.NewSnippetWriter(&b, ctx, "$", "$")
		sw.Do(GenerateSetterForPointerToBuiltinType(test.root, test.parent, test.member))
		assert.NoError(t, sw.Error())
		assert.Equal(t, test.want, b.String())
	}
}

func TestFuncName(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name string
		kind types.Kind
		want string
	}{
		{
			name: "Name",
			kind: types.Builtin,
			want: "WithName",
		},
		{
			name: "Struct",
			kind: types.Struct,
			want: "WithStruct",
		},
		{
			name: "Slice",
			kind: types.Slice,
			want: "AppendSlice",
		},
	}

	for _, test := range tests {
		m := types.Member{
			Name: test.name,
			Type: &types.Type{
				Kind: test.kind,
			},
		}

		assert.Equal(t, test.want, funcName(m))
	}
}
